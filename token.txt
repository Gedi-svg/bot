const polygonBaseTokens: Tokens = {
  wbnb: { symbol: 'WMATIC', address: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270' },
  usdt: { symbol: 'USDT', address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F' },
  USDC: { symbol: 'USDC', address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174' },
};

const polygonQuoteTokens: Tokens = {
  ETH: { symbol: 'ETH', address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619' },
  DAI: { symbol: 'DAI', address: '0x6b175474e89094c44da98b954eedeac495271d0f' },
  AAVE: { symbol: 'AAVE', address: '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9' },
  UNI: { symbol: 'UNI', address: '0xb33eaad8d922b1083446dc23f610c2567fb5180f' },
  SUSHI: { symbol: 'SUSHI', address: '0x0b3f868e0be5597d5db7feb59e1cadbb0fdda50a' },
  QUICK: { symbol: 'QUICK', address: '0x831753dd7087cac61ab5644b308642cc1c33dc13' },
  TUSD: { symbol: 'TUSD', address: '0x2e1AD108fF1D8C782fcBbB89AAd783aC49586756' },
  ATOM: { symbol: 'ATOM', address: '0xac51C4c48Dc3116487eD4BC16542e27B5694Da1b' },
  BAL: { symbol: 'BAL', address: '0x9a71012b13ca4d3d0cdc72a177df3ef03b0e76a3' },
  EMON: { symbol: 'EMON', address: '0xd6a5ab46ead26f49b03bbb1f9eb1ad5c1767974a' },
  COMBO: { symbol: 'COMBO', address: '0x6ddb31002abc64e1479fc439692f7ea061e78165' },
  BUSD: { symbol: 'BUSD', address: '0xdab529f40e671a1d4bf91361c21bf9f0c9712ab7' },
   mm: { symbol: 'MM', address: '0xf6a09deadf5a10aa7822d95e3228b2315de8f6fa' },
  revv: { symbol: 'REVV', address: '0x70c006878a5a50ed185ac4c87d837633923de296' },
  ice: { symbol: 'ICE', address: '0xc6C855AD634dCDAd23e64DA71Ba85b8C51E5aD7c' },
  game: { symbol: 'GAME', address: '0x8d1566569d5b695d44a9a234540f68D393cDC40D' },
  chp: { symbol: 'CHP', address: '0x59B5654a17Ac44F3068b3882F298881433bB07Ef' },
  dmr: { symbol: 'DMR', address: '0x955ce23f20217a6aa205620b40ede4c9e83d325f' },
  yup: { symbol: 'YUP', address: '0x086373fad3447F7F86252fb59d56107e9E0FaaFa' },
  paint: { symbol: 'PAINT', address: '0x7c28F627eA3aEc8B882b51eb1935f66e5b875714' },
  swash: { symbol: 'SWASH', address: '0xbA3CB8329D442E6F9Eb70fafe1E214251df3D275' },
  pruf: { symbol: 'PRUF', address: '0xAdf72D32E511eE00c6E0FF5D62Cd5C7C40A6aDEA' },
  web3: { symbol: 'WEB3', address: '0xBcD2C5C78000504EFBC1cE6489dfcaC71835406A' },
  udt: { symbol: 'UDT', address: '0xf7e78d9c4c74df889a83c8c8d6d05bf70ff75876' },
  uctc: { symbol: 'UCTC', address: '0xD4b42287F1EE04aF246aD792153C39D62733f826' },
  uct: { symbol: 'UCT', address: '0xfd5962484BE2c3574D70131BF5D452CcC7C69F67' },
  iq: { symbol: 'IQ', address: '0xB9638272aD6998708de56BBC0A290a1dE534a578' },
  trade: { symbol: 'TRADE', address: '0x692AC1e363ae34b6B489148152b12e2785a3d8d6' },
};
const polygonDexes: AmmFactories = {
  quickswap: '0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32',
  PolyDEX: '0xC60aE14F2568b102F8Ca6266e8799112846DD088',
  polycat: '0x477Ce834Ae6b7aB003cCe4BC4d8697763FF456FA',
  sushiswap: '0xc35DADB65012eC5796536bD9864eD8773aBc74C4',
  apeswap: '0xCf083Be4164828f00cAE704EC15a36D711491284',
  polymm: '0x7cFB780010e9C861e03bCbC7AC12E013137D47A5',
  DFYN: '0xE7Fb3e833eFE5F9c441105EB65Ef8b261266423B',
  JETSWAP: '0x668ad0ed2622C62E24f0d5ab6B6Ac1b9D2cD4AC7',
};
const wethFactory = (await ethers.getContractAt('IWMATIC', WMATIC)) as IWMATIC;
    wmatic = wethFactory.attach(WMATIC) as IWMATIC;

    const fbFactory = await ethers.getContractFactory('FlashBot');
    flashBot = (await fbFactory.deploy(WMATIC)) as FlashBot;


    zk pass: eR5Uus@6kvmpFjk

    ---------------------------------------------------------------------------

    async function updateCombinations(network: Network): Promise<TokenCombination[]> {
  // Fetch base and quote tokens for the network
  const [baseTokens, quoteTokens] = getTokens(network);

  let combinations: TokenCombination[] = [];

  // Generate combinations of three tokens
  for (const baseKey in baseTokens) {
    const baseToken = baseTokens[baseKey];
    for (const quote1Key in quoteTokens) {
      const quoteToken1 = quoteTokens[quote1Key];
      for (const quote2Key in quoteTokens) {
        if (quote1Key === quote2Key) continue; // Ensure different tokens
        const quoteToken2 = quoteTokens[quote2Key];
        
        // Construct combination
        const combination: TokenCombination = {
          symbols: `${baseToken.symbol}-${quoteToken1.symbol}-${quoteToken2.symbol}`,
          addresses: [baseToken.address, quoteToken1.address, quoteToken2.address],
          pairs: []
        };
        combinations.push(combination);
      }
    }
  }
  let factories: Contract[] = [];
  const factoryAddrs = getFactories(network);
  for (const key in factoryAddrs) {
    const addr = factoryAddrs[key]; // Assume a single factory in this case
    const factory = new ethers.Contract(addr, ['function getPool(address tokenA, address tokenB, uint24 fee) view returns (address pool)'], ethers.provider);
    factories.push(factory);
  }
  const feeTiers = [500, 3000, 10000]; // Define the fee tiers you are interested in
  
  for (const combination of combinations) {
    // Try to fetch the pool for each fee tier and add it to the pairs array if it exists
    const [pool0, pool1, pool2] = await Promise.all(
      feeTiers.map(fee => Promise.all([
        factories[0].getPool(combination.addresses[0], combination.addresses[1], fee),
        factories[1].getPool(combination.addresses[1], combination.addresses[2], fee),
        factories[2].getPool(combination.addresses[2], combination.addresses[0], fee)
      ]))
    );

    // Add valid pools to the combination
    combination.pairs.push(
      pool0.find(pool => pool !== ethers.constants.AddressZero),
      pool1.find(pool => pool !== ethers.constants.AddressZero),
      pool2.find(pool => pool !== ethers.constants.AddressZero)
    );
  }

  return combinations;
}
----------------------------------------------------------------------
if (profit >= gasFee) {
            profit -= gasFee;
        } else {
            profit = 0; // Ensure profit cannot be negative
        }
        -------------------------------------------------------------------------------------------

        import { ethers } from 'hardhat';
import { FlashArbitrageV3 } from '../typechain/FlashArbitrageV3';
import { Vault } from '../typechain/Vault';
import { expect } from 'chai';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
import { IUniswapV3Factory } from '../typechain/IUniswapV3Factory';
import { Mock } from '../typechain/Mock';
describe('Flash Arbitrage', function () {
  let flashContract: FlashArbitrageV3;
  let vaultContract: Vault;
  let signer: SignerWithAddress;
  let uniswapFactory: IUniswapV3Factory;
  let mockFactory: MockUniswapV3Factory;
  let mockPoolAB: MockUniswapV3Pool;
  let mockPoolBC: MockUniswapV3Pool;
  let mockPoolCA: MockUniswapV3Pool;
  const posman = '0xC36442b4a4522E871399CD717aBDD847Ab11FE88';
  const WMATIC = '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270';
  const uniRout = '0x1F98431c8aD98523631AE4a59f267346ea31F984';
  const USDT = '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'; //wmatic
  const ETH = '0xb33eaad8d922b1083446dc23f610c2567fb5180f'; //uni
  const UNI = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619'; //quic

  before(async function () {
        [signer] = await ethers.getSigners();
        const MockFactory = await ethers.getContractFactory('MockUniswapV3Factory');
        const MockPool = await ethers.getContractFactory('MockUniswapV3Pool');

        mockFactory = await MockFactory.deploy();
        mockPoolAB = await MockPool.deploy(1234567890, 100, 1000);
        mockPoolBC = await MockPool.deploy(1234567890, 100, 1000);
        mockPoolCA = await MockPool.deploy(1234567890, 100, 1000);

        await mockFactory.setPool(USDT, ETH, 500, mockPoolAB.address);
        await mockFactory.setPool(ETH, UNI, 500, mockPoolBC.address);
        await mockFactory.setPool(UNI, USDT, 500, mockPoolCA.address);
        const FlashContract = await ethers.getContractFactory('FlashArbitrageV3');
        const VaultContract = await ethers.getContractFactory('Vault');
        vaultContract = (await VaultContract.deploy(USDT, ETH, UNI)) as Vault;
        flashContract = (await FlashContract.deploy(WMATIC, uniRout, posman)) as FlashArbitrageV3;
        console.log("Contract deployed to address:", flashContract.address);
        console.log("Contract deployed to address:", vaultContract.address);
        uniswapFactory = await ethers.getContractAt('IUniswapV3Factory', uniRout); 
  });

  it('should add and remove base tokens correctly', async function () {
    const newToken = '0x0000000000000000000000000000000000000001';
    await flashContract.addBaseToken(newToken);
    let baseTokens = await flashContract.getBaseTokens();
    expect(baseTokens).to.include(newToken);

    await flashContract.removeBaseToken(newToken);
    baseTokens = await flashContract.getBaseTokens();
    expect(baseTokens).to.not.include(newToken);
  });

  it('should revert if trying to perform flash arbitrage with invalid token paths', async function () {
    const invalidTokenA = USDT;
    const invalidTokenB = ETH;
    const invalidTokenC = UNI;
    const gasFee = 100;
    const amountIn = 1000;

    await expect(
      flashContract.executeFlashArbitrage(invalidTokenA, invalidTokenB, invalidTokenC, amountIn, 0, gasFee, vaultContract.address)
    ).to.be.reverted;
  });

  it('should revert if trying to perform flash arbitrage with insufficient input amount', async function () {
    const tokenA = USDT;
    const tokenB = ETH;
    const tokenC = UNI;
    const gasFee = 100;
    const insufficientAmountIn = 10;

    await expect(
      flashContract.executeFlashArbitrage(tokenA, tokenB, tokenC, insufficientAmountIn, 0, gasFee, vaultContract.address)
    ).to.be.reverted;
  });

  it('should calculate profit correctly', async function () {
    const baseTokens = await flashContract.getBaseTokens();
    console.log('Base Tokens:', baseTokens);

    for (const tokenA of baseTokens) {
      for (const tokenB of baseTokens) {
        if (tokenA === tokenB) continue;

        const gasFee = 1;
        const profit = await flashContract.getProfit(tokenA, tokenB, gasFee, vaultContract.address);
        console.log(`Profit for pair ${tokenA}, ${tokenB}: ${profit}`);
        
        expect(profit).to.be.gte(0);
      }
    }
  });

  it('should execute flash arbitrage correctly', async function () {
    const tokenA = USDT;
    const tokenB = ETH;
    const tokenC = UNI;
    const gasFee = 1;

    const pairAddressAB = await uniswapFactory.getPool(tokenA, tokenB, 500);
    const pairAddressBC = await uniswapFactory.getPool(tokenB, tokenC, 500);
    const pairAddressCA = await uniswapFactory.getPool(tokenC, tokenA, 500);

    console.log('Pair Address AB:', pairAddressAB);
    console.log('Pair Address BC:', pairAddressBC);
    console.log('Pair Address CA:', pairAddressCA);

    if (!pairAddressAB || !pairAddressBC || !pairAddressCA) {
      console.error("One or more pair addresses are invalid. Exiting test.");
      return;
    }
    // Get the reserves of the token pairs
    const reservesAB = await flashContract.getOrderedReserves(tokenA, tokenB, vaultContract.address);
    const reservesBC = await flashContract.getOrderedReserves(tokenB, tokenC, vaultContract.address);
    const reservesCA = await flashContract.getOrderedReserves(tokenC, tokenA, vaultContract.address);
    
    console.log("Reserves AB:", reservesAB);
    console.log("Reserves BC:", reservesBC);
    console.log("Reserves CA:", reservesCA);

    // Check if reserves are valid
    if (!reservesAB || !reservesBC || !reservesCA) {
      console.error("One or more reserve values are invalid. Exiting test.");
      return;
    }

    const amountIn = 10; // Set a reasonable amount for testing

    await flashContract.executeFlashArbitrage(tokenA, tokenB, tokenC, amountIn, 0, gasFee, vaultContract.address);
    expect(await flashContract.getTokenBalance(tokenA)).to.equal(0);
    expect(await flashContract.getTokenBalance(tokenB)).to.equal(0);
    expect(await flashContract.getTokenBalance(tokenC)).to.equal(0);
  });
});










function uniswapV3Call(
    address sender,
    bytes memory data
) public {
    // Access control: Ensure only the permissioned pair can call this
    require(msg.sender == permissionedPairAddress, "Non-permissioned address call");
    require(sender == address(this), "Not from this contract");

    // Decode the callback data to get the relevant information
    CallbackData memory info = abi.decode(data, (CallbackData));

    // Perform the first hop: from the borrowed token to the intermediate token
    ISwapRouter.ExactInputParams memory params1 = ISwapRouter.ExactInputParams({
        path: abi.encodePacked(
            info.borrowedToken, uint24(3000), // Swap from borrowed token to intermediate
            info.intermediateToken, uint24(3000)  // Intermediate token for the next hop
        ),
        recipient: address(this),
        deadline: block.timestamp + 60,
        amountIn: info.debtAmount,
        amountOutMinimum: 1 // Minimum output for slippage protection
    });

    uint256 intermediateAmount = swapRouter.exactInput(params1);

    // Perform the second hop: from the intermediate token to the debt token
    ISwapRouter.ExactInputParams memory params2 = ISwapRouter.ExactInputParams({
        path: abi.encodePacked(
            info.intermediateToken, uint24(3000),  // Intermediate token
            info.debtToken // Final token to repay the debt
        ),
        recipient: address(this),
        deadline: block.timestamp + 60,
        amountIn: intermediateAmount,
        amountOutMinimum: 1 // Ensure profitable outcome
    });

    uint256 outputAmount = swapRouter.exactInput(params2);

    // Check if we need to swap back from the debt token to the borrowed token
    if (info.borrowedToken != info.debtToken) {
        ISwapRouter.ExactInputParams memory params3 = ISwapRouter.ExactInputParams({
            path: abi.encodePacked(
                info.debtToken, uint24(3000), // Swap from debt token back to borrowed token
                info.borrowedToken
            ),
            recipient: address(this),
            deadline: block.timestamp + 60,
            amountIn: outputAmount,
            amountOutMinimum: 1 // Ensure minimum output
        });

        // Perform the swap back to the borrowed token
        outputAmount = swapRouter.exactInput(params3);
    }

    // Repay the debt pool with the received amount from the final hop or the swap back
    require(outputAmount >= info.debtAmount, "Insufficient output to cover debt");
    IERC20(info.borrowedToken).safeTransfer(info.debtPool, info.debtAmount);

    // After the swap is complete, check profit (optional but recommended for extra safety)
    // Ensure we made a profit after repaying the debt
    uint256 profit = IERC20(info.borrowedToken).balanceOf(address(this)) - info.debtAmount;
    require(profit > 0, "No profit made from arbitrage");
}













/*
    function executeSwap(
        address[] memory path, 
        uint256 amountIn, 
        uint256 expectedProfit // Pass arbInfo as an argument
    ) internal {
        ArbitrageInfo memory arbInfo;
        ReserveDataBundle memory reserveBundle;
        // Add slippage protection: Set minimum output to ensure profitability
        uint256 minOutput = expectedProfit > 0 ? expectedProfit : 1;

        // Assuming reserveBundle has been filled with sqrtPriceX96 values before
        uint160[3] memory sqrtPriceLimits = reserveBundle.sqrtPriceX96;

        // Get the debt amount needed for the first swap (borrow amount)
        uint256 debtAmount = getAmountInWithQuoter(amountIn, path[0], path[1], 3000, sqrtPriceLimits[0]); // Pool fee 0.3%

        // Ensure we are correctly setting the CallbackData struct for the swap
        CallbackData memory callbackData = CallbackData({
            debtPool: arbInfo.lowerPool,             // Pool with lower price for borrowing
            targetPool: arbInfo.middlePool,          // Next pool for the swap
            finalPool: arbInfo.higherPool,           // Final pool to repay the debt
            debtTokenSmaller: arbInfo.baseSmaller,   // Whether the base token is smaller
            borrowedToken: arbInfo.baseSmaller ? arbInfo.quoteToken0 : arbInfo.baseToken0, // Borrowed token
            intermediateToken: path[1],              // Intermediate token for the multi-hop swap
            debtToken: arbInfo.baseSmaller ? arbInfo.baseToken0 : arbInfo.quoteToken0, // Debt token to be repaid
            debtAmount: debtAmount,                   // Amount borrowed
            debtTokenOutAmount: minOutput             // To be set during the swap
        });

        // Set the permissioned pair to the lower pool for callback origin authentication
        permissionedPairAddress = arbInfo.lowerPool;

        // Ensure the contract has enough balance before the borrowing process
        uint256 balanceBefore = IERC20(callbackData.borrowedToken).balanceOf(address(this));

        // Perform the first swap in the lower pool (borrow token)
        IUniswapV3Pool(arbInfo.lowerPool).swap(
            address(this),            // Recipient of the swap
            arbInfo.baseSmaller,      // True if swapping token0 for token1, false otherwise
            -int256(debtAmount),      // Negative value to initiate a flash swap
            sqrtPriceLimits[0],       // Sqrt price limit for the first pool
            abi.encode(callbackData)   // Pass encoded callback data for Uniswap V3 callback
        );

        // Set the permissioned pair to the middle pool for the second swap
        permissionedPairAddress = arbInfo.middlePool;

        // Get the amount out for the second swap (intermediate token)
        uint256 baseTokenOutAmount1 = getAmountOutWithQuoter(debtAmount, path[0], path[1], 3000, sqrtPriceLimits[0]);

        // Perform the second swap in the middle pool
        IUniswapV3Pool(arbInfo.middlePool).swap(
            address(this),            // Recipient of the swap
            arbInfo.baseSmaller,      // True if swapping token0 for token1, false otherwise
            int256(baseTokenOutAmount1), // Positive value for a normal swap
            sqrtPriceLimits[1],       // Sqrt price limit for the second pool
            abi.encode(callbackData)   // Pass encoded callback data for Uniswap V3 callback
        );

        // Set the permissioned pair to the final pool for the final swap
        permissionedPairAddress = arbInfo.higherPool;

        // Get the amount out for the final swap (repaying the debt)
        uint256 finalTokenOutAmount = getAmountOutWithQuoter(baseTokenOutAmount1, path[1], path[2], 3000, sqrtPriceLimits[1]);

        // Perform the final swap in the higher pool
        IUniswapV3Pool(arbInfo.higherPool).swap(
            address(this),            // Recipient of the swap
            arbInfo.baseSmaller,      // True if swapping token0 for token1, false otherwise
            int256(finalTokenOutAmount), // Positive value for a normal swap
            sqrtPriceLimits[2],       // Sqrt price limit for the third pool
            abi.encode(callbackData)   // Pass encoded callback data for Uniswap V3 callback
        );

        // After all swaps are done, check the balance after the swaps
        uint256 balanceAfter = IERC20(callbackData.borrowedToken).balanceOf(address(this));
        require(balanceAfter > balanceBefore, "Losing money");

        // If the token is WETH, withdraw to ETH
        if (callbackData.borrowedToken == WETH) {
            IWETH(callbackData.borrowedToken).withdraw(balanceAfter);
        }

        // Reset the permissioned pair after the swap is completed
        permissionedPairAddress = address(1);

        emit FlashArbitrageExecuted(amountIn, minOutput);
    }


    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes memory data
    ) public override{
        // Access control: Ensure only the permissioned pair can call this
        require(msg.sender == permissionedPairAddress, "Non-permissioned address call");
        

        // Decode the callback data to get the relevant information
        CallbackData memory info = abi.decode(data, (CallbackData));

        // Determine if we need to send amount0 or amount1
        if (amount0Delta > 0) {
            // Sending borrowedToken for amount0
            IERC20(info.borrowedToken).safeTransfer(msg.sender, uint256(amount0Delta));
        } else if (amount1Delta > 0) {
            // Sending debtToken for amount1
            IERC20(info.debtToken).safeTransfer(msg.sender, uint256(amount1Delta));
        }
        // Perform the first hop: from the borrowed token to the intermediate token
        ISwapRouter.ExactInputParams memory params1 = ISwapRouter.ExactInputParams({
            path: abi.encodePacked(
                info.borrowedToken, uint24(3000), // Swap from borrowed token to intermediate
                info.intermediateToken, uint24(3000)  // Intermediate token for the next hop
            ),
            recipient: address(this),
            deadline: block.timestamp + 60,
            amountIn: info.debtAmount,
            amountOutMinimum: 1 // Minimum output for slippage protection
        });

        uint256 intermediateAmount = swapRouter.exactInput(params1);

        // Perform the second hop: from the intermediate token to the debt token
        ISwapRouter.ExactInputParams memory params2 = ISwapRouter.ExactInputParams({
            path: abi.encodePacked(
                info.intermediateToken, uint24(3000),  // Intermediate token
                info.debtToken // Final token to repay the debt
            ),
            recipient: address(this),
            deadline: block.timestamp + 60,
            amountIn: intermediateAmount,
            amountOutMinimum: 1 // Ensure profitable outcome
        });

        uint256 outputAmount = swapRouter.exactInput(params2);

        // Check if we need to swap back from the debt token to the borrowed token
        if (info.borrowedToken != info.debtToken) {
            ISwapRouter.ExactInputParams memory params3 = ISwapRouter.ExactInputParams({
                path: abi.encodePacked(
                    info.debtToken, uint24(3000), // Swap from debt token back to borrowed token
                    info.borrowedToken
                ),
                recipient: address(this),
                deadline: block.timestamp + 60,
                amountIn: outputAmount,
                amountOutMinimum: 1 // Ensure minimum output
            });

            // Perform the swap back to the borrowed token
            outputAmount = swapRouter.exactInput(params3);
        }

        // After the swaps, calculate the profit
        uint256 contractBalance = IERC20(info.borrowedToken).balanceOf(address(this));
        require(contractBalance >= info.debtAmount, "Insufficient output to cover debt");

        // Separate profit before repaying the debt
        uint256 profit = contractBalance - info.debtAmount;

        // Take profit by transferring to a specified address (owner or profit-taking contract)
        IERC20(info.borrowedToken).safeTransfer(address(this), profit);

        // Repay the debt pool with the remaining amount
        IERC20(info.borrowedToken).safeTransfer(info.debtPool, info.debtAmount);

        // Emit an event with the profit details
        emit FlashArbitrageExecuted(info.debtAmount, profit);
    }*












    function calculateProfit(
        uint256 borrowAmount,
        address[] memory path,
        uint160[3] memory sqrtPrices // Token path for arbitrage
    ) public returns (uint256 profit) {
        // Ensure the path has at least 2 tokens (for arbitrage to make sense)
        require(path.length == 3, "Path must have 3 tokens for 3-pool arbitrage");

        // Use the Quoter to calculate debt amount (input amount needed to get the borrowed amount)
        uint256 debtAmount = getAmountInWithQuoter(borrowAmount, path[0], path[1], 3000, sqrtPrices[0]); // Pool fee 0.3%

        // Sell the borrowed token (path[0]) for the middle token (path[1]) in the second pool
        uint256 baseTokenOutAmount1 = getAmountOutWithQuoter(debtAmount, path[1], path[2], 3000, sqrtPrices[1]);

        // Sell the middle token (path[1]) for the final token (path[2]) in the third pool
        uint256 finalTokenOutAmount = getAmountOutWithQuoter(baseTokenOutAmount1, path[2], path[0], 3000, sqrtPrices[2]);

        // Check if the arbitrage is profitable
        if (finalTokenOutAmount < debtAmount) {
            profit = 0; // No profit, arbitrage not successful
        } else {
            profit = finalTokenOutAmount.sub(debtAmount); // Calculate the net profit
        }

        // Return the calculated profit
        return profit;
    }